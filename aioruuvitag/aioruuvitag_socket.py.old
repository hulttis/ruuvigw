# coding=utf-8
# !/usr/bin/python3
# Name:         ruuvitag_socket - bluetooth receiver
#
# Author:       Timo Koponen
#
# Created:      07.04.2019
# Copyright:    (c) 2019
# Licence:      MIT
#
# AF_BLUETOOTH

# ------------------------------------------------------------------------------
import logging
logger = logging.getLogger('aioruuvitag_ble')

import os
import sys
import array
import fcntl
import asyncio
import socket
import struct
import threading
from contextlib import suppress
from datetime import datetime as _dt
from datetime import timedelta
from queue import Queue

from .ruuvitag_misc import get_sec as _get_sec
from .ruuvitag_misc import Device, BDAddress, hex_string

if not sys.platform.startswith('linux') or os.environ.get('CI') == 'True': 
    # WINDOWS - JUST TO REMOVE ERRORS
    socket.AF_BLUETOOTH = 0
    socket.BTPROTO_HCI = 0
    socket.SOL_HCI = 0
    socket.HCI_FILTER = 0

# USED CONSTANTS
HCI_COMMAND_PKT = 0x01
HCI_EVENT_PKT = 0x04
EVT_LE_META_EVENT = 0x3e
EVT_CMD_COMPLETE = 0x0e
EVT_CMD_STATUS = 0x0f
HCIGETDEVINFO = -2147202861 #0x800448d3L  # _IOR(ord('H'), 211, 4)
OGF_LE_CTL = 0x08
OCF_LE_SET_SCAN_PARAMETERS = 0x000B
OCF_LE_SET_SCAN_ENABLE = 0x000C
LE_SET_SCAN_PARAMETERS_CMD = OCF_LE_SET_SCAN_PARAMETERS | OGF_LE_CTL << 10
LE_SET_SCAN_ENABLE_CMD = OCF_LE_SET_SCAN_ENABLE | OGF_LE_CTL << 10
SCAN_TYPE_ACTIVE  = 0x01
LE_PUBLIC_ADDRESS = 0x00
FILTER_POLICY_NO_WHITELIST = 0x00


# ==============================================================================
# ruuvitag_socket class
# ==============================================================================
class ruuvitag_socket(object):
# ------------------------------------------------------------------------------
    def __init__(self, *, device=0):
        #print(f'>>> BluetoothHCIAdapter::__init__() device:{device}')

        if not device:
            l_device_id = 0
        else:
            l_device_id = int(device.replace('hci', ''))
        self.device_id = l_device_id
        self._run = True
        self._socket = None
        self._thread = None
        self._callback = None
        self.device = None
        
        self._scheduler = None
        self._loop = None
        self._task = None
        self._device_timeout = 10
        self._data_ts = 0
        
# ------------------------------------------------------------------------------
    def __repr__(self):
        return '''ruuvitag_socket(device_id={}, callback='{}', thread={})'''.format(self.device_id, self._callback, self._thread)

# ------------------------------------------------------------------------------
    def __del__(self):
        self.close()

#-------------------------------------------------------------------------------
    def _schedule(self):
        logger.debug(f'>>> enter {type(self._scheduler)} device_timeout:{self._device_timeout}')
        
        if not self._scheduler:
            return

        if self._device_timeout:
            l_jobid = f'socket_timeout'
            try:
                self._scheduler.add_job(
                    self._do_socket_timeout,
                    'interval',
                    seconds = 1,
                    kwargs = {
                        'jobid': l_jobid
                    },
                    id = l_jobid,
                    replace_existing = True,
                    max_instances = 1,
                    coalesce = True,
                    next_run_time = _dt.now()+timedelta(seconds=self._device_timeout)
                )
                logger.info(f'>>> jobid:{l_jobid} scheduled')
            except:
                logger.exception(f'*** jobid:{l_jobid} exception')

#-------------------------------------------------------------------------------
    async def _do_socket_timeout(self, *,
        jobid
    ):
        """
        Supervises reception of the socket data
        Restarts async cmd process if no data received within timeout period - device_timeout
        """
        l_now = _get_sec()
        if (l_now - self._data_ts) > self._device_timeout:
            logger.warning(f'>>> jobid:{jobid} device_timeout timer ({self._device_timeout}ms) expired')
            try:
                logger.info(f'>>> jobid:{jobid} restarting socket')
                # await self.close()
                # await self.open()
            except:
                logger.exception(f'*** jobid:{jobid}')

# ------------------------------------------------------------------------------
    async def open(self):
        self._socket = socket.socket(family=socket.AF_BLUETOOTH, type=socket.SOCK_RAW, proto=socket.BTPROTO_HCI)
        self._socket.setblocking(False)
        self._socket.bind((self.device_id,))
        self._thread = threading.Thread(target=self._poller, name='SocketPoller')
        self._thread.setDaemon(True)
        self._thread.start()
        self.device = self._device_info()

# ------------------------------------------------------------------------------
    async def close(self):
        self._run = False
        await asyncio.sleep(0.2)
        self._socket.close()

# ------------------------------------------------------------------------------
    async def _poller(self):
        while self._run:
            l_data = self._socket.recv(1024)    # blocking
            await self._on_data(data=l_data)

# ------------------------------------------------------------------------------
    def _device_info(self):
        dev_info_struct = struct.Struct('=H 8s 6B L B 8B 3L 4I 10L')
        l_request= dev_info_struct.pack(
            self.device_id,
            b'',
            0, 0, 0, 0, 0, 0,
            0,
            0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        l_response = self._send_cmd(cmd=HCIGETDEVINFO, data=l_request)
        l_dev_info = dev_info_struct.unpack(l_response)
        # l_device_id = l_dev_info[0]
        l_device_name = l_dev_info[1].split(b'\0',1)[0]
        l_bd_address = l_dev_info[2:8]

        l_device = Device(address=BDAddress(l_bd_address), name=l_device_name)
        return l_device

# ------------------------------------------------------------------------------
    def _send_cmd(self, *, cmd, data):
        l_arr = array.array('B', data)
        fcntl.ioctl(self._socket.fileno(), cmd, l_arr)
        return l_arr

# ------------------------------------------------------------------------------
    def _send_data(self, *, data):
        self._socket.send(data)

# ------------------------------------------------------------------------------
    def _set_filter(self, *, data):
        self._socket.setsockopt(socket.SOL_HCI, socket.HCI_FILTER, data)

# ------------------------------------------------------------------------------
    def _set_scan_filter(self):
        l_typeMask   = 1 << HCI_EVENT_PKT
        l_eventMask1 = (1 << EVT_CMD_COMPLETE) | (1 << EVT_CMD_STATUS)
        l_eventMask2 = 1 << (EVT_LE_META_EVENT - 32)
        l_opcode     = 0

        l_filter = struct.pack("<LLLH", l_typeMask, l_eventMask1, l_eventMask2, l_opcode)
        self._set_filter(data=l_filter)

# ------------------------------------------------------------------------------
    def _set_scan_parameters(self):
        l_len = 7
        l_type = SCAN_TYPE_ACTIVE
        l_internal = 0x0010   #  ms * 1.6
        l_window = 0x0010     #  ms * 1.6
        l_own_addr  = LE_PUBLIC_ADDRESS
        l_filter = FILTER_POLICY_NO_WHITELIST
        l_cmd = struct.pack("<BHBBHHBB", HCI_COMMAND_PKT, LE_SET_SCAN_PARAMETERS_CMD, l_len, l_type, l_internal, l_window, l_own_addr, l_filter )

        self._send_data(data=l_cmd)
        
# ------------------------------------------------------------------------------
    def _enable_scan(self, *, enabled=False, filter_duplicates=False):
        l_len = 2
        enable = 0x01 if enabled else 0x00
        dups   = 0x01 if filter_duplicates else 0x00
        l_cmd = struct.pack("<BHBBB", HCI_COMMAND_PKT, LE_SET_SCAN_ENABLE_CMD, l_len, enable, dups)
        self._send_data(data=l_cmd)                

# ------------------------------------------------------------------------------
    def start_scanning(self):
        self._enable_scan(enabled=False)
        self._set_scan_filter()
        self._set_scan_parameters()
        self._enable_scan(enabled=True, filter_duplicates=False)

# ------------------------------------------------------------------------------
    def stop_scanning(self):
        self._enable_scan(enabled=False)        
        
# ------------------------------------------------------------------------------
    async def _on_data(self, *, data):
        if data:
            if data[0] == HCI_EVENT_PKT:
                if data[1] == EVT_LE_META_EVENT:
                    _, _, l_len = struct.unpack("<BBB", data[:3])
                    l_data = data
                    if l_len > 40:
                        print(f'''Event Packet: len:{l_len} data:{hex_string(data=l_data)}''')
                else:
                    print(f'Unhandled HCI event packet, subtype={data[1]} data:{hex_string(data=data[2:])}')
            else:
                print(f'Unhandled HCI packet, type={data[0]} data:{hex_string(data=data[1:])}')

# ------------------------------------------------------------------------------
    async def _get_lines(self, *,
        loop,
        callback
    ):
        """
        Receives data from socket 
        """
        while not self._get_lines_stop.is_set():
            try:
                l_rawdata = await loop.sock_recv(self._socket, 1024)
                logger.debug(f'>>> rawdata:{l_rawdata}')
                await callback(rawdata=l_rawdata)
            except asyncio.TimeoutError:
                logger.error(f'>>> TimeoutError. restarting AF_BLUETOOTH socket')
                await self.close()
                await self.open()
                pass
            except asyncio.CancelledError:
                logger.warning(f'>>> CanceledError')
                return
            except Exception:
                logger.exception(f'*** exception')
                return

# -------------------------------------------------------------------------------
    def start(self, *, 
        callback
    ):
        """
        Starts to receive from AF_BLUETOOTH socket
        """
        if not self._loop:
            self._loop = asyncio.get_running_loo()
        if not callback:
            print(f'>>> callback not defined')
            return False

        logger.info(f'>>> starting to receive from the AF_BLUETOOTH socket')
        self._get_lines_stop = asyncio.Event(loop=self._loop)
        self._task = loop.create_task(self._get_lines(loop=self._loop, callback=callback))
        logger.info('>>> get_lines task created')

# -------------------------------------------------------------------------------
    def stop(self):
        """
        Stops AF_BLUETOOTH socket
        """
        logger.info(f'>>> stop to receive from AF_BLUETOOTH socket')
        self._get_lines_stop.set()
        if self._task:
            self._task.cancel()
            with suppress(asyncio.CancelledError):
                self._loop.run_until_complete(asyncio.wait_for(self._task, timeout=2.0))
            logger.info('>>> get_lines task canceled')

